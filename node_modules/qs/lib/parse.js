<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
'use strict';

var Utils = require('./utils');

<<<<<<< HEAD
=======
// Load modules

var Utils = require('./utils');


// Declare internals

>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
var internals = {
    delimiter: '&',
    depth: 5,
    arrayLimit: 20,
    parameterLimit: 1000,
    strictNullHandling: false,
    plainObjects: false,
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
    allowPrototypes: false,
    allowDots: false
};

internals.parseValues = function (str, options) {
    var obj = {};
    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

    for (var i = 0; i < parts.length; ++i) {
<<<<<<< HEAD
=======
    allowPrototypes: false
};


internals.parseValues = function (str, options) {

    var obj = {};
    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

    for (var i = 0, il = parts.length; i < il; ++i) {
>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
        var part = parts[i];
        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

        if (pos === -1) {
            obj[Utils.decode(part)] = '';

            if (options.strictNullHandling) {
                obj[Utils.decode(part)] = null;
            }
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
        } else {
            var key = Utils.decode(part.slice(0, pos));
            var val = Utils.decode(part.slice(pos + 1));

            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                obj[key] = [].concat(obj[key]).concat(val);
            } else {
                obj[key] = val;
            }
<<<<<<< HEAD
=======
        }
        else {
            var key = Utils.decode(part.slice(0, pos));
            var val = Utils.decode(part.slice(pos + 1));

            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                obj[key] = val;
            }
            else {
                obj[key] = [].concat(obj[key]).concat(val);
            }
>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
        }
    }

    return obj;
};

<<<<<<< HEAD
<<<<<<< HEAD
internals.parseObject = function (chain, val, options) {
=======

internals.parseObject = function (chain, val, options) {

>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
internals.parseObject = function (chain, val, options) {
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
    if (!chain.length) {
        return val;
    }

    var root = chain.shift();

    var obj;
    if (root === '[]') {
        obj = [];
        obj = obj.concat(internals.parseObject(chain, val, options));
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
    } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
        var index = parseInt(cleanRoot, 10);
        if (
            !isNaN(index) &&
            root !== cleanRoot &&
            String(index) === cleanRoot &&
            index >= 0 &&
            (options.parseArrays && index <= options.arrayLimit)
        ) {
            obj = [];
            obj[index] = internals.parseObject(chain, val, options);
        } else {
<<<<<<< HEAD
=======
    }
    else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
        var index = parseInt(cleanRoot, 10);
        var indexString = '' + index;
        if (!isNaN(index) &&
            root !== cleanRoot &&
            indexString === cleanRoot &&
            index >= 0 &&
            (options.parseArrays &&
             index <= options.arrayLimit)) {

            obj = [];
            obj[index] = internals.parseObject(chain, val, options);
        }
        else {
>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
            obj[cleanRoot] = internals.parseObject(chain, val, options);
        }
    }

    return obj;
};

<<<<<<< HEAD
<<<<<<< HEAD
internals.parseKeys = function (givenKey, val, options) {
    if (!givenKey) {
=======

internals.parseKeys = function (key, val, options) {

    if (!key) {
>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
internals.parseKeys = function (givenKey, val, options) {
    if (!givenKey) {
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
        return;
    }

    // Transform dot notation to bracket notation
<<<<<<< HEAD
<<<<<<< HEAD
    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;
=======

    if (options.allowDots) {
        key = key.replace(/\.([^\.\[]+)/g, '[$1]');
    }
>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8

    // The regex chunks

    var parent = /^([^\[\]]*)/;
    var child = /(\[[^\[\]]*\])/g;

    // Get the parent

    var segment = parent.exec(key);

    // Stash the parent if it exists

    var keys = [];
    if (segment[1]) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
<<<<<<< HEAD
<<<<<<< HEAD
        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
=======
        if (!options.plainObjects &&
            Object.prototype.hasOwnProperty(segment[1])) {

>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(segment[1]);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
<<<<<<< HEAD
<<<<<<< HEAD
        i += 1;
        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
=======

        ++i;
        if (!options.plainObjects &&
            Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {

>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
        i += 1;
        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
            if (!options.allowPrototypes) {
                continue;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return internals.parseObject(keys, val, options);
};

<<<<<<< HEAD
<<<<<<< HEAD
module.exports = function (str, opts) {
    var options = opts || {};
=======

module.exports = function (str, options) {

    options = options || {};
>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
module.exports = function (str, opts) {
    var options = opts || {};
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
<<<<<<< HEAD
<<<<<<< HEAD
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;
=======
    options.allowDots = options.allowDots !== false;
>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;

<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
    if (
        str === '' ||
        str === null ||
        typeof str === 'undefined'
    ) {
<<<<<<< HEAD
=======
    if (str === '' ||
        str === null ||
        typeof str === 'undefined') {

>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
<<<<<<< HEAD
<<<<<<< HEAD
    for (var i = 0; i < keys.length; ++i) {
=======
    for (var i = 0, il = keys.length; i < il; ++i) {
>>>>>>> cec199920473bbfd13a946ef7466a6f270502933
=======
    for (var i = 0; i < keys.length; ++i) {
>>>>>>> 35df532d073310745d0bf1b49f0ed615cabd29d8
        var key = keys[i];
        var newObj = internals.parseKeys(key, tempObj[key], options);
        obj = Utils.merge(obj, newObj, options);
    }

    return Utils.compact(obj);
};
